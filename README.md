# ProbeTools
<b>Flexible, user-friendly hybridization probe design for diverse viral taxa</b>

ProbeTools is a collection of Python scripts for designing hybridization probe sequences against viral taxa with extensive genomic diversity. It uses a heuristic k-mer clustering algorithm. All probe-length k-mers are enumerated from a set of provided reference genomes, then these k-mers are clustered based on nucleotide sequence similarity. Centroids sequences, i.e. the k-mers that seeded each cluster, are extracted as candidate probe sequences. Centroids are ranked based on the number of k-mers in the clusters they represent; centroids from larger clusters are assumed to make better probes because of their similarity to more k-mers within the provided reference sequence target space. This process can be improved by designing probe panels incrementally, adding smaller batches of probes and removing already-covered sub-sequences from the target space between batches.

# Core tools
ProbeTools consists of four core Python scripts for probe design applications:
1. <b>makeprobes.py</b>: enumerates probe-length k-mers from target space FASTA file, clusters k-mers, and ranks candidate probe sequences based on cluster sizes
2. <b>capture.py</b>: predicts target space coverage by provided probe panel
3. <b>getlowcov.py</b>: extracts sub-sequences from target with low probe coverage and writes them to a new FASTA file
4. <b>stats.py</b>: calculates statistics about the depth and extent of target space coverage by provided probe panel

The ProbeTools scripts are modular and can be chained together in various ways to achieve the desired result. The following approach is recommended as a departure point for probe design projects:
1. <b>Optional target space pre-clustering:</b> This can be done using any clustering program, e.g. VSEARCH (REFERENCE). This step is optional and will depend on the intended purpose of the probe panel. Certain viral taxa are over-represented in databases where viral sequences are obtained, usually due to their agricultural and/or public health significance. ProbeTools will bias its designs towards over-represented sequences and the k-mers they contain. If the purpose of the panel is disease surveillance and detection of reportable viral taxa, this ProbeTools bias could be considered a feature more than a flaw, and target space pre-clustering might be undesirable. If the purpose of the panel is the recovery lineages that are not as well represented in sequence databases, pre-clustering is probably appropriate. Depending on the size, number, and complexity of viral genomes, this pre-clustering step might also be computationally expensive and impractical.
2. <b>Single batch designs to estimate required panel size:</b> Run makeprobes.py once, generating the full panel. Create smaller panels covering a range of sizes by copying the top-n probe sequences from the full panel. Since probe sequences are outputted in descending order of predicted inclusivity, this approach will generate the most effective panels across this range of panel sizes. Coverage predictions for these panels can be generated by running capture.py and stats.py for each panel. These results will provide a rough indication of how many probe sequences will be required to achieve a desired level of target space coverage. They might also indicate a panel size where additional probes from the single-batch design provide diminishing marginal target coverage.
3. <b>Incremental batch designs to improve panel coverage:</b> Run makeprobes.py, generating one tenth of the total number of probes anticipated. Run capture.py on this batch of probes, then run getlowcov.py to create a FASTA containing all parts of the target space not covered by this batch. Run makeprobes.py again, still generating one tenth of the total number of probes anticipated, but this time run it on the FASTA file created by getlowcov.py. Repeat this process until the total anticipated number of probes has been generated, and combine all batches of probes into one panel. Run capture.py and stats.py on the combined panel and compare the target space coverage metrics to a panel of the same size designed as a single batch. You will notice an improvement from removing already-covered sub-sequences from the target space between batches.

# User-friendly incremental design
A generalized incremental design strategy has been implemented in a convenient fifth script called incrementalprobes.py. The user provides the following:
1. A FASTA file containing viral reference sequences
2. The number of probes designed per batch
3. The level of coverage desired for the top 90% of reference sequences
4. The maxmimum number of probes in the panel

The incrementalprobes.sh script will perform an incremental design strategy on the provided target space, adding the indicated number of probes each batch. It will continue adding batches until the desired coverage target is achieved or the panel contains the maximum number of probes, whichever occurs first. Smaller batch sizes will result in better coverage from more compact panel sizes, but increase the computation time required for the design.

# ProbeTools Setup

1. Download the ProbeTools code:
```
git clone https://github.com/KevinKuchinski/ProbeTools.git
```
2. Create the ProbeTools environment:
```
conda env create -f ProbeTools_env.yml
```

# ProbeTools Usage

<b>makeprobes.py</b>
```
$ python makeprobes.py -t <target_space_FASTA.fa> -o <job_name> [-n MAX -i 90 -k 120 -s 1 -d 0]
```
This script enumerates k-mers from the provided FASTA of target sequences and clusters them to provide candidate probe sequences. Clustering is done using VSEARCH CLUSTER_FAST [https://github.com/torognes/vsearch , Rognes et al., PeerJ (2016)].

<u>Arguments</u>

  -t : The name and path of a FASTA file containing target sequences to design probes against.
  
  -o : A job name that will be appended to output files. Makeprobes.py generates one output file: a FASTA file of probe sequences ranked in descending order of predicited effectiveness (job_name_probes.fa).
  
  -n : The number of probe sequences to generate. By default, makeprobes.py generates all posible probe sequences given the specified k-mer enumeration and clustering parameters.
  
  -i : The nucleotide sequence identity threshold used to cluster the k-mers enumerated from the target sequences. By default, 90% identity is used.
  
  -k : The length of k-mers enumerated from target sequences, i.e. the desired probe length. By default, 120mers are enumerated.
  
  -s : The step size between k-mers, i.e. the number of positions the sliding window advances eeach time it enumerates a k-mer. By default, the window advances by 1 positions after each k-mer.
  
  -d : The maximum number of degenerate bases permitted in a k-mer. By default, k-mers containing degenerate bases are not enumerated.

<b>capture.py</b>
```
$ python capture.py -t <target_space_FASTA.fa> -p <probes_FASTA.fa> -o <job_name> [-r <previous_capture.pt> -i 90 -l 60]
```
This script aligns all provided probe sequences against all provded target sequences to predict the panel's coverage. Alignments are filtered based on their length and nucleotide sequence identities. Alignments are done with BLAST+ [https://blast.ncbi.nlm.nih.gov/Blast.cgi?CMD=Web&PAGE_TYPE=BlastDocs&DOC_TYPE=Download].

  -t : The name and path of a FASTA file containing target sequences to assess probes against.
  
  -p : The name and path of a FASTA containing probe sequences to assess.
  
  -o : A job name that will be appended to output files. Capture.py generates one output file: a PT file of providing the depth of probe coverage across each nucleotide position in the provided target sequences (job_name_capture.pt). See below for details on the .pt format.
  
  -r : The name and path of a .pt formatted file previously-generated by capture.py. If such a file is provided, the current results will be appended to these previous results. This is useful during incremental design. Imagine you are adding 100 probes to a panel that already contains 900 probes, and that you have already run capture.py for these 900 previously-designed probes. You want to see probe coverage for the new 100 probes combined with the previous 900 probes but don't want to re-compute all the alignments for the previously-analyzed 900 probes. Capture.py will only compute alignments for the new 100 probes, but add them to the existing depth of coverage results from the 900 probes. N.B. in this situtaion, capture.py will only align the new 100 probes against targets provided in the targets sequences FASTA; if the previous capture results included targets not in the current target space FASTA, probe depth across those targets will be reported in the new file, but not reflect potential additional coverage from the new probes.
  
  -i : The nucleotide sequence identity threshold used to filter alignments between probe sequences and target sequences.
  
  -l : The minimum alignment length used to filter alignments between probe sequences and target sequences.

<b>getlowcov.py</b>
```
$ python getlowcov.py -i <CAPT_input.capt> -o <job_name> [-d 0 -l 10 -w 120]
```
This script extracts sub-sequences with low coverage from a provide .pt capture results file.

<u>Arguments</u>

  -i : The name and path of a .pt formatted file previously-generated by capture.py.
  
  -o : A job name that will be appended to output files. Getlowcov.py generates one output file: a FASTA file of low coverage regions in the provided targets (job_name_low_cov.fa).
  
  -d : The probe depth threshold considered low coverage. Nucleotides with fewer than this number of probes mapped to them will be considered low coverage.
  
  -l : The minimum number of contiguous low coverage bases required for a low coverage region.
  
  -w : The window size, i.e. the minimum number of bases to write-out around a low coverage region. The window size should equal or exceed the probe length, otherwise makeprobes.py will not be able to enumerate any k-mers from the sequence. If the low coverage region is smaller than the window size, getlowcov.py will centre the window on the low coverage region and write out the entire window, even if the window contains already-covered sequence. If the low coverage region is too close to the start or the end of the target sequence, the window will be shifted accordingly.

<b>stats.py</b>
```
$ python stats.py -i <CAPT_input.capt> -o <job_name>
```
This script analyzes a provided .pt capture results file and calculates statistics about the capture. 

<u>Arguments</u>

  -i : The name and path of a .pt formatted file previously-generated by capture.py.
  
  -o : A job name that will be appended to output files. Stats.py generates two output files: a long-form TSV file where statistics are provided for each target sequence, and a summary text table with overall statistics for the entire target space.

<b>incrementalprobes.py</b>
```
$ python incrementalprobes.py -t <target_space_FASTA.fa> -o <job_name> -b <batch_size> -m <max_probes_in_panel> -c <coverage_target>
```
The script automates a generalized incremental design process. Probes will be generated against the provided target space FASTA, adding a number of probes each batch specified by <batch_size>. New batches will be added until one of end-point conditions is met: the panel contains the maximum number of probes, or the 10th percentile of target coverage reaches the coverage target, or there is no remaining uncovered sequence in the target space. At this point, the final probe panel will be complete (job_name_final_probes.fa), and statistics will be generated on the final probe panel design (job_name_final_summary.tsv and job_name_final_long.tsv). 

# .pt Format Specifications
The .pt format is largely derived from the FASTA format. Each entry spans three lines, each starting with its own identifying character:

<b>Entry header (>):</b> A text header to describe the sequence. Do not use spaces in the header.

<b>Entry sequence ($):</b> The nucleotide sequence of the entry.

<b>Entry probe depths (#):</b> A comma-separated list of the number of probes covering each nucleotide position. The order of the list follows the order of the nucleotide sequence, i.e. the 4th number of the list describes the number probes covering the 4th nucletoide of the entry's sequence.

<u>Example entry:</u>
```
>Entry_header
$ATGCGTTGACAGTGCACACG
#1,1,1,1,1,2,2,2,2,2,1,1,2,2,2,3,3,3,3,3
```
