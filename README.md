# ProbeTools
<b>Flexible, user-friendly hybridization probe design for diverse viral taxa</b>

ProbeTools is a collection of Python scripts for designing hybridization probe sequences against viral taxa with extensive genomic diversity. It uses a heuristic k-mer clustering algorithm. All probe-length k-mers are enumerated from a set of provided reference genomes, then these k-mers are clustered based on nucleotide sequence similarity. Centroids sequences, i.e. the k-mers that seeded each cluster, are extracted as candidate probe sequences. Centroids are ranked based on the number of k-mers in the clusters they represent; centroids from larger clusters are assumed to make better probes because of their similarity to more k-mers within the provided reference sequence target space. This process can be improved by designing probe panels incrementally, adding smaller batches of probes and removing already-covered sub-sequences from the target space between batches.

# Core tools
ProbeTools consists of four core Python scripts for probe design applications:
1. <b>makeprobes.py</b>: enumerates probe-length k-mers from target space FASTA file, clusters k-mers, and ranks candidate probe sequences based on cluster sizes
2. <b>capture.py</b>: predicts target space coverage by provided probe panel
3. <b>getlowcov.py</b>: extracts sub-sequences from target with low probe coverage and writes them to a new FASTA file
4. <b>stats.py</b>: calculates statistics about the depth and extent of target space coverage by provided probe panel

The ProbeTools scripts are modular and can be chained together in various ways to achieve the desired result. The following approach is recommended as a departure point for probe design projects:
1. <b>Optional target space pre-clustering:</b> This can be done using any clustering program, e.g. VSEARCH (REFERENCE). This step is optional and will depend on the intended purpose of the probe panel. Certain viral taxa are over-represented in databases where viral sequences are obtained, usually due to their agricultural and/or public health significance. ProbeTools will bias its designs towards over-represented sequences and the k-mers they contain. If the purpose of the panel is disease surveillance and detection of reportable viral taxa, this ProbeTools bias could be considered a feature more than a flaw, and target space pre-clustering might be undesirable. If the purpose of the panel is the recovery lineages that are not as well represented in sequence databases, pre-clustering is probably appropriate. Depending on the size, number, and complexity of viral genomes, this pre-clustering step might also be computationally expensive and impractical.
2. <b>Single batch designs to estimate required panel size:</b> Run makeprobes.py once, generating the full panel. Create smaller panels covering a range of sizes by copying the top-n probe sequences from the full panel. Since probe sequences are outputted in descending order of predicted inclusivity, this approach will generate the most effective panels across this range of panel sizes. Coverage predictions for these panels can be generated by running capture.py and stats.py for each panel. These results will provide a rough indication of how many probe sequences will be required to achieve a desired level of target space coverage. They might also indicate a panel size where additional probes from the single-batch design provide diminishing marginal target coverage.
3. <b>Incremental batch designs to improve panel coverage:</b> Run makeprobes.py, generating one tenth of the total number of probes anticipated. Run capture.py on this batch of probes, then run getlowcov.py to create a FASTA containing all parts of the target space not covered by this batch. Run makeprobes.py again, still generating one tenth of the total number of probes anticipated, but this time run it on the FASTA file created by getlowcov.py. Repeat this process until the total anticipated number of probes has been generated, and combine all batches of probes into one panel. Run capture.py and stats.py on the combined panel and compare the target space coverage metrics to a panel of the same size designed as a single batch. You will notice an improvement from removing already-covered sub-sequences from the target space between batches.

# User-friendly incremental design
A generalized incremental design strategy has been implemented in a convenient fifth script called incrementalprobes.py. The user provides the following:
1. A FASTA file containing viral reference sequences
2. The number of probes designed per batch
3. The level of coverage desired for the top 90% of reference sequences
4. The maxmimum number of probes in the panel

The incrementalprobes.sh script will perform an incremental design strategy on the provided target space, adding the indicated number of probes each batch. It will continue adding batches until the desired coverage target is achieved or the panel contains the maximum number of probes, whichever occurs first. Smaller batch sizes will result in better coverage from more compact panel sizes, but increase the computation time required for the design.

# ProbeTools Setup

1. Download the ProbeTools code:
```
git clone https://github.com/KevinKuchinski/ProbeTools.git
```
2. Create the ProbeTools environment:
```
conda env create -f ProbeTools_env.yml
```

# ProbeTools Usage

<b>makeprobes.py</b>
```
$ python makeprobes.py -t <target_space_FASTA.fa> -o <job_name> [-n MAX -i 90 -k 120 -s 1 -d 0]
```
  -t : The name and path of a FASTA file containing target sequences to design probes against.
  
  -o : A job name that will be appended to output files. Makeprobes.py generates one output file: a FASTA file of probe sequences ranked in descending order of predicited effectiveness.
  
  -n : The number of probe sequences to generate. By default, makeprobes.py generates all posible probe sequences given the specified k-mer enumeration and clustering parameters.
  
  -i : The nucleotide sequence identity threshold used to cluster the k-mers enumerated from the target sequences. By default, 90% identity is used.
  
  -k : The length of k-mers enumerated from target sequences, i.e. the desired probe length. By default, 120mers are enumerated.
  
  -s : The step size between k-mers, i.e. the number of positions the sliding window advances eeach time it enumerates a k-mer. By default, the window advances by 1 positions after each k-mer.
  
  -d : The maximum number of degenerate bases permitted in a k-mer. By default, k-mers containing degenerate bases are not enumerated.

<b>capture.py</b>
```
$ python capture.py -t <target_space_FASTA.fa> -p <probes_FASTA.fa> -o <job_name> [-r <previous_capture.pt> -i 90 -l 60]
```
-t : The name and path of a FASTA file containing target sequences to assess probes against.
  
  -p : The name and path of a FASTA containing probe sequences to assess.
  
  -o : A job name that will be appended to output files. Capture.py generates one output file: a PT file of providing the depth of probe coverage across each nucleotide position in the provided target sequences. See below for details on the .pt format.
  
  -r : The name and path of a .pt formatted file previously-generated by capture.py. If such a file is provided, the current results will be appended to these previous results. This is useful during incremental design. Imagine you are adding 100 probes to a panel that already contains 900 probes, and that you have already run capture.py for these 900 previously-designed probes. You want to see probe coverage for the new 100 probes combined with the previous 900 probes but don't want to re-compute all the alignments for the previously-analyzed 900 probes. Capture.py will only compute alignments for the new 100 probes, but add them to the existing depth of coverage results from the 900 probes. N.B. in this situtaion, capture.py will only align the new 100 probes against targets provided in the targets sequences FASTA; if the previous capture results included targets not in the current target space FASTA, probe depth across those targets will be reported in the new file, but not reflect potential additional coverage from the new probes.

<b>getlowcov.py</b>
```
$ python getlowcov.py -i <CAPT_input.capt> -o <lowcov_regions_FASTA_output.fa> [-d 0 -l 10 -w 120]
```
    
<b>stats.py</b>
```
$ python stats.py -i <CAPT_input.capt> -o <panel_name_descriptor>
```

<b>incrementalprobes.py</b>
```
$ bash incrementalprobes.sh</b> <target_space_FASTA.fa> <batch_size> <coverage_target> <max_probes> <panel_name_descriptor>
```

# .pt Format Specifications
